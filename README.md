# algorithms
This repository contains my algorithms projects

## Project 1: Psychic Modeling, brute force vs. heuristic design

### Description
The two programs solve the psychic modeling problem from "The Algorithm Design Manual" by Steven Skiena . The first program,  `psychicoptimal.java`, solves the problem optimally (using brute force, testing all possibilities). This works for small problems. For the second program, `psychicheuristic.java` I designed a heuristic that gives a good solution, but is not necessarily optimal. This works for both small and large problems.

### Build & Run
The input and output of both problems are the same: the input is read from a text file, and the output is written to a text file. The names of the input and output files should be specified on the command line (first input file, then output file).

1. Pull from `develop`.
2. Open `terminal` (`Command + Space`, then search for "terminal").
3. `cd` into the same directory as where your code for algorithms is stored.
For example, if my code is on the Desktop, then I'll need to use `cd Desktop/algorithms`.
4. Complile programs, using `javac psychicoptimal.java` and `javac psychicheuristic.java`
5. Create an input `.txt` file, using the format specifyed in "Input File" Section. The format is same for both programs. Make sure you don't feed large problem to `psychicoptimal.java`, since it is a bruite fource and may take a long time to solve large problems.
6. Run programs by using `java psychicoptimal output_name.txt` for first (brute force) program and  `java psychicheuristic input_name.txt output_name.txt` for second (heuristic) program.

### Input File
The input file should have just one line and the format of that line should be:
`njkl` where
- n is the number of candidate values supplied by the psychic (15 in the example problem in the text),
- j is the number of these candidate values guaranteed to be correct (6 in the example),
- k is the number of slots on each ticket (6 in the example), and
- l is the number of correct values on the ticket necessary to win something (2 in the example).
For the sake of consistency between everyone’s output, assume that the n candidate values are {1, 2, . . . , n}.

### Output File
- The first line of the output file is the number of tickets to buy to guarantee the buyer has at least one ticket with at least l winning numbers of it.
- The following lines of the file are the tickets to buy, one ticket per line, with a ticket specified by the numbers on the ticket. The numbers on a ticket should be listed smallest to largest. The tickets should be listed lexicographically (tickets with smallest first number should be listed first, break ties with the next number, and so on). The numbers on a single ticket should be separated by white spaces, so no commas.

### Example
For example (and this is the small example in the book), if the input is
`5332`
then the output can be (the solution is not unique)
```
2
123
145
```
---

## Project 2: Sudoku Solver

### Description
This a program to solves an arbitrary [Sudoku problem](https://en.wikipedia.org/wiki/Sudoku). It takes two command line arguments: the first is the name of the file containing the problem specification (format is below), and the second is the name of the file to write the solution to (format is below). This program solves problems in a timely manner.

### Build & Run
1. Pull from `develop` if you have not done it yet.
2. Open `terminal` (`Command + Space`, then search for "terminal").
3. `cd` into the same directory as where your code for algorithms is stored.
For example, if my code is on the Desktop, then I'll need to use `cd Desktop/algorithms`.
4. Create an input `.txt` file, using the format specifyed in "Input File" Section.
5. Complile and run the program, using `python sudoku.py input_name.txt output_name.txt`

### Input File
The input file contains one line for each number specified in the problem. The format for a line is:
`row col num`, where
- row is the row of the number (rows are numbered 1 through 9),
- col is the column of the number (columns are numbered 1 through 9), and
- num is the number (valid numbers are 1 through 9). The numbers can be specified in any order. (They do not necessarily appear, for example, row by row, or column by column.) The three entries on a row are separated by one or more spaces.

### Output File
The output file contents depends on if the problem is feasible. If the problem is not feasible, then the format of the output file is
```
Infeasible
Number of solution space nodes generated = xxx
```
Here, xxx represents the number of solution spaces nodes generated by your program.
If the problem is feasible, then the format of the output file is
```
row1
row2
row3
row4
row5
row6
row7
row8
row9
Number of solution space nodes generated = xxx
```

Each line contains a row of the solution, with one space between the 9 values in the row. Here, xxx represents the number of solution spaces nodes generated by your program.

---

## Project 3: Dynamic Preogramming

### Description
A program is given a string `x = x1x2 · · · xn` from an alphabet of k symbols, and a multiplication table over this alphabet. It finds all ways to parenthesize x in such a way that the value of the resulting expression is v, where v belongs to the alphabet. If this is not possible, then the message `Not possible` is displayed. The multiplication table is neither commutative or associative, so the order of multiplication matters.
If the description is not clear, check out `Example` subsection.

The program uses dynamic programming to solve the problem. This is the approach I took to develop it:
1. I thought recursively about the solving the problem
2. I came up with a family of subproblems.
3. I filled in the solutions to the subproblems in a table, and then grabbed the solution to the original problem out of this table. In this case, the solutions to the subproblems are lists of parenthesized strings that meet some criteria.

### Build & Run
This program gets the problem input from a file whose name is specified by the first command line argument, and it writes the results to a file whose name is the second command line argument.

1. Pull from `develop` if you have not done it yet.
2. Open `terminal` (`Command + Space`, then search for "terminal").
3. `cd` into the same directory as where your code for algorithms is stored.
For example, if my code is on the Desktop, then I'll need to use `cd Desktop/algorithms`.
4. Complile the program, using `javac parse.java`
5. Create an input `.txt` file, using the format specifyed in "Input File" Section.
6. Run programs by using `java parse input_name.txt output_name.txt`.

### Input File
The format of the input file is as follows:
- The first line contains the alphabet, with no leading or embedded whitespace spaces (so no whitespace characters are permitted in the alphabet).
- The next n lines (where n is the number of characters in the alphabet) contain the multiplication table. The lines do not contain any leading or embedded whitespace characters.
- The next line contains the string that is to produce the desired result. The line does not contain any leading or embedded whitespace characters.
- The next line contains a single character (no leading spaces) that is the target result.

For the example in `Example` section (where the target result is b), the contents of the input file will be
```
abc
acb
cab
bac
babc
b
```
The program can assumes that the input file is correctly formatted.

### Output File
The output file contains a complete list of all possible ways to parenthesize the input string so as to give the target result. There is one parenthesized string per line, with no leading, embedded, or trailing whitespace characters.
The program prints the strings in lexicographic order, where the lexicographic order is defined by the following rules: To compare strings s1 and s2,
1. If the first character of s1 is a ‘(’ and the first character of s2 is not a ‘(’, then s2 comes first in the ordering.
2. If the first character of s2 is a ‘(’ and the first character of s1 is not a ‘(’, then s1 comes first in the ordering.
3. If the first characters of s1 and s2 are either both ‘(’ or both not ‘(’, then continue the comparison with the next character.
4. Continue the comparisons character by character until either the first or second rule determines the ordering.
5. If both strings are identical, except that one is shorter, the shorter string comes first in the ordering. (This should not happen in the context of this program.)
If it is not possible to parenthesize the input string to get the target result, the program prints just the statement `Not possible` .

For the example in `Example` section (where the target result is b), the contents of the output file will be
```
b(a(bc))
b((ab)c)
(b(ab))c
((ba)b)c
```

### Example
For example, suppose that the alphabet is `{a, b, c}`, the string is `babc`, the multiplication table is
```
abc
aacb
bcab
cbac
```
and the target result is `b`, then the possible ways to parenthesize babc are `b(a(bc))`, `b((ab)c)`,` (b(ab))c`, and `((ba)b)c`. If the target result is `a` (with the string and multiplication table the same), then the only way to parenthesize babc is `(ba)(bc)`. And if the target result is `c` (with the string and multiplication table the same), then there is no way to parenthesize `babc` to get the target result.

Consider example above, where the target result is b. Then the content of the input file to the program will be:
```
abc
acb
cab
bac
babc
b
```
And the program will output:
```
b(a(bc))
b((ab)c)
(b(ab))c
((ba)b)c
```

